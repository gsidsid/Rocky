
// Tunes compatible with the Pololu 32U4 Buzzer library
const char fugue[] PROGMEM =
 "! T144 L16 O6" "ag#gf#gf#fe fee-dc#cO5bb-" "ag#gf#gf#fe fee-dc#co4bb-" "ag#gf#gf#fe ag#gf#gf#fe" "ag#gf#fb-ag# ag#gf#ff#g#" "ag#gf#fb-ag# ag#gf#ff#g#" "ag#gf#gf#fe ff#gg#ab-ag#" "ag#gf#gf#fe ff#gg#abO5cc#" "dc#cO4bb-O5e-dc# dc#cO4bb-bO5cc#" "dc#cO4bb-O5e-dc# dc#cO4bb-bO5cc#" "dc#cO4b>cbb-a b-bO5cc#de-dc" "dc#cO4b>cbb-a b-bO5cc#de-dc" "dO4dMSdddddd e-de-O5e-e-de->e-" "dddddddd e-de->e-e-de-O6e-" "MLdO5e-dc#de-dc# de-dc#de-dc#" "de-eff#fee- de-eff#fee-" "dO4gMSgggggg a-ga->a-a-ga->a-" "gO5ggggggg a-ga->a-a-ga-O6a-" "MLfO5a-gf#ga-af# ga-gf#ga-gf#" "ga-ab-bb-aa- ga-ab-bb-aa-" "gf#fee-a-gf# gf#fee-eff#" "gf#fefee-d e-eff#ff#gg#" "ag#gf#gf#fe fee-dc#cO4bb-" "ab-ag#ab-ag# ab-ag#ab-ag#" "ab-ag#ab-ag# ab-ag#ab-ag#" "ag#gf#gf#fe fee-dc#cO3bb-" "ab-ag#ab-ag# ab-ag#ab-ag#" "ab-ag#ab-ag# ab-ag#ab-ag#" "ab-bO4cc#dd#e ff#gg#ab-bO5c" "c#dd#eff#gg# ab-ag#ab-ag#" "ag#gf#fb-ag# ag#gf#ff#g#" "ag#gf#fb-ag# ag#gf#ff#g#" "ag#gf#gf#fe ff#gg#ab-ag#" "ag#gf#gf#fe ff#gg#abO5cc#" "dc#cO4bb-O5e-dc# dc#cO4bb-bO5cc#" "dc#cO4bb-O5e-dc# dc#cO4bb-bO5cc#" "dc#cO4b>cbb-a b-bO5cc#de-dc" "dc#cO4b>cbb-a b-bO5cc#de-dc" "dO4dMSdddddd e-de-O5e-e-de->e-" "dddddddd e-de->e-e-de-O6e-" "MLdO5e-dc#de-dc# de-dc#de-dc#" "de-eff#fee- de-eff#fee-" "dO4gMSgggggg a-ga->a-a-ga->a-" "gO5ggggggg a-ga->a-a-ga-O6a-" "MLfO5a-gf#ga-af# ga-gf#ga-gf#" "ga-ab-bb-aa- ga-ab-bb-aa-" "gf#fee-a-gf# gf#fee-eff#" "gf#fefee-d e-eff#ff#gg#" "ag#gf#gf#fe fee-dc#cO4bb-" "ab-ag#ab-ag# ab-ag#ab-ag#" "ab-ag#ab-ag# ab-ag#ab-ag#" "ag#gf#gf#fe fee-dc#cO3bb-" "ab-ag#ab-ag# ab-ag#ab-ag#" "ab-ag#ab-ag# ab-ag#ab-ag#" "ab-bO4cc#dd#e ff#gg#ab-bO5c" "c#dd#eff#gg# ab-ag#ab-ag#" "ag#gf#fb-ag# ag#gf#ff#gg#" "ag#gf#fb-ag# ag#gf#ff#gg#" "ag#gf#gf#fe ff#gg#ab-ag#" "ag#gf#gf#fe ff#gg#abO6cc#" "dc#c<b<b-e-dc# dc#cO5bb-bO6cc#" "dc#c<b<b-e-dc# dc#cO5bb-bO6cc#" "dc#c<bcO5bb-a b-bO6cc#de-dc#" "dc#cO5bb-bO6cc# defgab-ag#" "ag#gf#fb-ag# ag#gf#ff#gg#" "ag#gf#fb-ag# ag#gf#ff#gg#" "a8c#de-eff# gf#fefee-d" "c#dd#eff#gg# ab-ag#ab-ag#" "a8O5c#de-eff# gf#fefee-d" "c#dd#eff#gg# ab-ag#abO6cc#" "dc#cO5bcbb-a b-ag#gf#fee-" "dc#cO4b>cbb-a b-ag#gf#fee-" "de-dc#e-de->e- de-dedfdg" "ab-ag#b>abO5b aR<ab<bO6cO4bO6c#" "L8dRL16O3ab-bO4c c#de-eff#gg#" "ab-bO5cc#de-e ff#gg#abO6cc#" "L2d O7d L4O5dR";

const char videogame[] PROGMEM =
 "v12 L16 o5 eererce8g8r8<g8r8"
  "c8.<gr8<e8.<a8<b8<b-<a8<g.e.g.a8fgre8cd<b8."
  "c8.<gr8<e8.<a8<b8<b-<a8<g.e.g.a8fgre8cd<b8."
  "r8gf#fd#8er<g#<acr<acd"
  "r8gf#fd#8er>c8>c>c4"
  "r8gf#fd#8er<g#<acr<acd"
  "r8e-8rd8.c4";

const char vic[] PROGMEM = "O6 T40 L16 d#<b<f#<d#<f#<bd#f#"
  "T80 c#<b-<f#<c#<f#<b-c#8"
  "T180 d#b<f#d#f#>bd#f#c#b-<f#c#f#>b-c#8 c>c#<c#>c#<b>c#<c#>c#c>c#<c#>c#<b>c#<c#>c#"
  "c>c#<c#>c#<b->c#<c#>c#c>c#<c#>c#<b->c#<c#>c#"
  "c>c#<c#>c#f>c#<c#>c#c>c#<c#>c#f>c#<c#>c#"
  "c>c#<c#>c#f#>c#<c#>c#c>c#<c#>c#f#>c#<c#>c#d#bb-bd#bf#d#c#b-ab-c#b-f#d#";
  
#include <Balboa32U4.h>
#include <Wire.h>
#include <LSM6.h>
#include "Balance.h"

#define METERS_PER_CLICK 3.141592*80.0*(1/1000.0)/12.0/(162.5)
#define MOTOR_MAX 300
#define MAX_SPEED 0.75  // m/s
#define FORTY_FIVE_DEGREES_IN_RADIANS 0.78

extern int32_t angle_accum;
extern int32_t anglex;
extern int32_t speedLeft;
extern int32_t driveLeft;
extern int32_t distanceRight;
extern int32_t speedRight;
extern int32_t distanceLeft;
extern int32_t distanceRight;

float lastDist=0;
float thetaError;
float thetaIntegrator;
float distanceIntegrator=0;
float phiLError;
float phiLIntegrator;
float phiRError;
float phiRIntegrator;
float vLError;
float vLIntegrator;
float vRError;
float vRIntegrator;
float theta_d;
float phi_d;
float vL, vR, totalDistanceLeft, totalDistanceRight;
float leftMotorPWM = 0;
float rightMotorPWM = 0;
float dt = 0.01;
float currPhi = 0;

void balanceDoDriveTicks();

extern int32_t displacement;
int32_t prev_displacement=0;

LSM6 imu;
Balboa32U4Motors motors;
Balboa32U4Encoders encoders;
Balboa32U4Buzzer buzzer;
Balboa32U4ButtonA buttonA;
Balboa32U4ButtonB buttonB;
Balboa32U4ButtonC buttonC;

// Distance PID control constants (Bring robot to some distance from initial position)
float Dp = 0.025;
float Di = 0.012;
float Dd = 0.04;

// Phi PI control constants (Aligning robot to some angle)
float Pp = -0.008;
float Pi = -0.0004;

// Pendulum PI control constants (Keeping robot upright)
float Ri = -36;
float Rp = -6;

// Cruise control constants (Managing robot PWM to constant wheel velocities)
float Kp = 500;
float Ki = 5000;

// State variables for controlling execution of events
bool stable = false;
bool planComplete = false;
bool startVic = true;
bool AState = false;
bool BState = false;
bool CState = false;

// Iterators for controlled resets on error integrators
int stable_iter = 0;
int integratorCycle = 5/0.01;
int integratorLife = 0;

void updatePWMs(float totalDistanceLeft, float totalDistanceRight, float vL, float vR, float angleRad, float angleRadAccum) {
  /* You will fill this function in with your code to run the race.  The inputs to the function are:
   *    totalDistanceLeft: the total distance travelled by the left wheel (meters) as computed by the encoders
   *    totalDistanceRight: the total distance travelled by the right wheel (meters) as computed by the encoders
   *    vL: the velocity of the left wheel (m/s) measured over the last 10ms
   *    vR: the velocity of the right wheel (m/s) measured over the last 10ms
   *    angleRad: the angle in radians relative to vertical
   *    angleRadAccum: the error in angle integrated over time
   */  
  
  if (!stable) {
    
    // launch control 
    stable = stabilize(150, 0, angleRad);
    
  } else 
  {
    // action
    if (AState) {
      // stabilize Rocky at initial position
      moveRocky(0,angleRad);
    } else if (BState) {
      // move Rocky 6.1 meters forward and attempt to stabilize at this range
      moveRocky(6.1,angleRad);
    } else if (CState) {
      // spin Rocky in place
      updateSPINPID(30, stand(av(totalDistanceLeft, totalDistanceRight)), angleRad);
    }

    // physical system constraints
    if (leftMotorPWM >= 300) {
      leftMotorPWM = 299;
    } else if (leftMotorPWM <= -300) {
      leftMotorPWM = -299;
    }
    if (rightMotorPWM <= -300) {
      rightMotorPWM = -299;
    } else if (rightMotorPWM >= 300) {
      rightMotorPWM = 299;
    }
  }
}

void turnRocky(float phi, float angleRad) {
  /* Experimental method to keep Rocky trained on some angle phi drawn on a plane parallel to the ground.
   *    phi: desired angle in radians to turn to
   *    angleRad: last known angle in radians on a perpendicular axis to phi reported from IMU 
   */
  float dist = av(totalDistanceLeft, totalDistanceRight);
  if (phi == 0) {
    updatePID(stand(dist),angleRad);
  } else if ( phi - abs(currPhi) > 0.035){
    updatePHIPID(phi, stand(dist),angleRad);
  } else {
    updatePID(stand(dist),angleRad);
  }
}

bool stabilize(int iterations, float distance, float angleRad) {
    /* Method used for stabilizing Rocky before the action phase to increase consistency of execution.
   *    iterations: control duration of launch control phase with a counter
   *    distance: distance from initial position in meters to attempt to stabilize at
   *    angleRad: last known angle in radians on a perpendicular axis to phi reported from IMU 
   */
  // executes for set number of iterations before returning true
  float dist = av(totalDistanceLeft, totalDistanceRight);
  stable_iter += 1;
  if (stable_iter < iterations) {
    updatePID(stand(abs(dist)-distance),angleRad);
    return false;
  } else {
    stable_iter = 0;
    return true;
  }
}

void moveRocky(float distance, float angleRad) {
  /*  Moves Rocky forward by a given distance.
   *    distance: number of meters forward Rocky must travel before stopping.
   *    angleRad: last known angle in radians on a perpendicular axis to phi reported from IMU 
   */
  // moves Rocky 'distance' meters forward, and stops Rocky after reaching set distance.
  distance = abs(distance);
  float dist = av(totalDistanceLeft, totalDistanceRight);
  if (distance == 0) {
    updatePID(stand(dist),angleRad);
  } else {
    if ((abs(dist) - distance) < 0 && !planComplete) {
      updatePID(forward(),angleRad);
    } else {
      planComplete = true;
      if ( startVic ) {
        buzzer.stopPlaying();
        buzzer.playFromProgramSpace(vic);
        startVic = false;
      }
      updatePID(stand(abs(dist)-distance),angleRad);
    }
  }
}


/* Following are PI control functions that use the global values of Kp, Ki, Rp, and Ri to control the Rocky system. 
 *    updatePID: Keeps Rocky upright, and attempts to keep Rocky inclined at a desired angle from the vertical
 *    updatePHIPID: Keeps Rocky upright, and attempts to make Rocky face a desired angle on the horizontal plane (parallel to ground).
 *    updateSPINPID: Keeps Rocky upright, and attempts to spin Rocky at a desired speed.
 */
 
void updatePID(float theta_d, float angleRad) {
  thetaError = theta_d-angleRad;
  thetaIntegrator += thetaError*dt;
  vLError = (Rp*thetaError+Ri*thetaIntegrator)-vL;
  vLIntegrator += vLError*dt;
  vRError = (Rp*thetaError+Ri*thetaIntegrator)-vR;
  vRIntegrator += vRError*dt;
  leftMotorPWM = Kp*vLError+Ki*vLIntegrator;
  rightMotorPWM = Kp*vRError+Ki*vRIntegrator;
}

void updatePHIPID(float phi_d, float theta_d, float angleRad) {
  thetaError = theta_d-angleRad;
  thetaIntegrator += thetaError*dt;
  phiLError = phi_d-currPhi;
  phiLIntegrator += phiLError*dt;
  phiRError = currPhi-phi_d;
  phiRIntegrator += phiRError*dt;
  vLError = (Rp*thetaError+Ri*thetaIntegrator)+(Pp*phiLError + Pi*phiLIntegrator)-vL;
  vLIntegrator += vLError*dt;
  vRError = (Rp*thetaError+Ri*thetaIntegrator)+(Pp*phiRError + Pi*phiRIntegrator)-vR;
  vRIntegrator += vRError*dt;
  leftMotorPWM = Kp*vLError+Ki*vLIntegrator;
  rightMotorPWM = Kp*vRError+Ki*vRIntegrator;
}

void updateSPINPID(float ang_vel_d, float theta_d, float angleRad) {
  thetaError = -0.035+theta_d/2-angleRad;
  thetaIntegrator += thetaError*dt;
  phiLError = ang_vel_d;
  phiRError = -ang_vel_d;
  vLError = (Rp*thetaError+Ri*thetaIntegrator)+(Pp*phiLError)-vL;
  vLIntegrator += vLError*dt;
  vRError = (Rp*thetaError+Ri*thetaIntegrator)+(Pp*phiRError)-vR;
  vRIntegrator += vRError*dt;
  leftMotorPWM = Kp*vLError+Ki*vLIntegrator;
  rightMotorPWM = Kp*vRError+Ki*vRIntegrator;
}

float spin() {
  return 30;
}

float stand(float distance) {
  // The numeric inverse of distance in meters may be used as the desired angle in radians for small angles (and small distances).
  return -distance;
}

float forward() {
  
  // Constants controlling Rocky's speed/motion
  float v = 0.12;
  float t = (millis()-150*10)/1000.0;
  
  // Tell Rocky to stand at various distances between the initial position and some final point
  distanceIntegrator += (v*t - av(totalDistanceLeft,totalDistanceRight))*0.01;
  theta_d = Dp*(v*t - av(totalDistanceLeft,totalDistanceRight)); //+ Di*distanceIntegrator + Dd*((av(totalDistanceLeft,totalDistanceRight) - lastDist)/0.01);
  lastDist = av(totalDistanceLeft,totalDistanceRight);
  
  return theta_d;
}

float av(float one, float two) {
  // Helper function for averaging encoder data
  return (one+two)/2.0;
}
  

uint32_t prev_time;

void setup()
{
  Wire.begin();

  Serial.begin(9600);
  Serial1.begin(9600);

  prev_time = 0;
  ledYellow(0);
  ledRed(1);
  balanceSetup();
  ledRed(0);
  angle_accum = 0;
  ledGreen(0);
  ledYellow(0);

}

extern int16_t angle_prev;
int16_t start_flag = 0;
int16_t armed_flag = 0;
int16_t start_counter = 0;
void lyingDown();
extern bool isBalancingStatus;
extern bool balanceUpdateDelayedStatus;

void newBalanceUpdate()
{
  static uint32_t lastMillis;
  uint32_t ms = millis();

  if ((uint32_t)(ms - lastMillis) < UPDATE_TIME_MS) { return; }
  balanceUpdateDelayedStatus = ms - lastMillis > UPDATE_TIME_MS + 1;
  lastMillis = ms;

  // call functions to integrate encoders and gyros
  balanceUpdateSensors();
 
  if (imu.a.x < 0)
  {
    lyingDown();
    isBalancingStatus = false;
  }
  else
  {
    isBalancingStatus = true;
  }
}


void loop()
{

  if (buttonA.getSingleDebouncedPress())
  {
      AState = true;
      BState = false;
      CState = false;
      while(!buttonA.getSingleDebouncedPress());
      ledGreen(1);
  } else if (buttonB.getSingleDebouncedPress())
  {
      AState = false;
      BState = true;
      CState = false;
      ledGreen(1);
      while(!buttonB.getSingleDebouncedPress());
  } else if (buttonC.getSingleDebouncedPress())
  {
      AState = false;
      BState = false;
      CState = true;
      ledGreen(1);
      while(!buttonC.getSingleDebouncedPress());
  }

  if (AState || BState || CState) {
  
  uint32_t cur_time = 0;
  static uint32_t prev_print_time = 0;   // this variable is to control how often we print on the serial monitor
  static float angle_rad;                // this is the angle in radians
  static float angle_rad_accum = 0;      // this is the accumulated angle in radians
  static float error_ = 0;      // this is the accumulated velocity error in m/s
  static float error_left_accum = 0;      // this is the accumulated velocity error in m/s
  static float error_right_accum = 0;      // this is the accumulated velocity error in m/s

  

  cur_time = millis();                   // get the current time in miliseconds



  newBalanceUpdate();                    // run the sensor updates. this function checks if it has been 10 ms since the previous 
  
  if(angle > 3000 || angle < -3000)      // If angle is not within +- 3 degrees, reset counter that waits for start
  {
    start_counter = 0;
  }

  bool shouldPrint = cur_time - prev_print_time > 105;
  if(shouldPrint)   // do the printing every 105 ms. Don't want to do it for an integer multiple of 10ms to not hog the processor
  {
        Serial1.print(currPhi);  
        Serial1.print("\t");
        Serial1.print(angle_rad);  
        Serial1.print("\t");
        Serial1.print(angle_rad_accum);  
        Serial1.print("\t");
        Serial1.print(leftMotorPWM);
        Serial1.print("\t");
        Serial1.print(rightMotorPWM);
        Serial1.print("\t");
        Serial1.print(vL);
        Serial1.print("\t");
        Serial1.print(vR);
        Serial1.print("\t");
        Serial1.print(totalDistanceLeft);
        Serial1.print("\t");
        Serial1.print(totalDistanceRight);
        Serial1.print("\t");
        Serial1.print(vLError);  
        Serial1.print("\t");
        Serial1.print(vLIntegrator);  
        Serial1.print("\t");
        Serial1.print(vRError);  
        Serial1.print("\t");
        Serial1.println(vRIntegrator);
        prev_print_time = cur_time;

        
/* Uncomment this and comment the above if doing wireless
        Serial1.print(angle_rad);  
        Serial1.print("\t");
        Serial1.print(angle_rad_accum);  
        Serial1.print("\t");
        Serial1.print(PWM_left);
        Serial1.print("\t");
        Serial1.print(PWM_right);
        Serial1.print("\t");
        Serial1.print(vL);
        Serial1.print("\t");
        Serial1.println(vR);
       */
  }

  float delta_t = (cur_time - prev_time)/1000.0+0.0000001;

  // handle the case where this is the first time through the loop
  if (prev_time == 0) {
    delta_t = 0.01;
  }
  
  // every UPDATE_TIME_MS, check if angle is within +- 3 degrees and we haven't set the start flag yet
  if(cur_time - prev_time > UPDATE_TIME_MS && angle > -3000 && angle < 3000 && !armed_flag)   
  {
    // increment the start counter
    start_counter++;
    // If the start counter is greater than 30, this means that the angle has been within +- 3 degrees for 0.3 seconds, then set the start_flag
    if(start_counter > 30)
    {
      armed_flag = 1;
      //buzzer.playFrequency(DIV_BY_10 | angle*10, 10, 150);
      if ( BState ) {
        buzzer.playFromProgramSpace(videogame);
      }
      
    }
  }

  // angle is in millidegrees, convert it to radians and subtract the desired theta
  angle_rad = ((float)angle)/1000/180*3.14159;

  // only start when the angle falls outside of the 3.0 degree band around 0.  This allows you to let go of the
  // robot before it starts balancing
  if(cur_time - prev_time > UPDATE_TIME_MS && (angle < -3000 || angle > 3000) && armed_flag)   
  {
    start_flag = 1;
    armed_flag = 0;
    angle_rad_accum = 0.0;
  }

  // every UPDATE_TIME_MS, if the start_flag has been set, do the balancing
  if(cur_time - prev_time > UPDATE_TIME_MS && start_flag)
  {
    // set the previous time to the current time for the next run through the loop
    prev_time = cur_time;

    // speedLeft and speedRight are just the change in the encoder readings
    // wee need to do some math to get them into m/s
    vL = METERS_PER_CLICK*speedLeft/delta_t;
    vR = METERS_PER_CLICK*speedRight/delta_t;

    totalDistanceLeft = METERS_PER_CLICK*distanceLeft;
    totalDistanceRight = METERS_PER_CLICK*distanceRight;
    angle_rad_accum += angle_rad*delta_t;
    currPhi = ((float)anglex)/1000/180*3.14159;
    updatePWMs(totalDistanceLeft, totalDistanceRight, vL, vR, angle_rad, angle_rad_accum);
    
    // if the robot is more than 45 degrees, shut down the motor
    if(start_flag && fabs(angle_rad) > FORTY_FIVE_DEGREES_IN_RADIANS)
    {
      // reset the accumulated errors here
      start_flag = 0;   /// wait for restart
      prev_time = 0;
      motors.setSpeeds(0, 0);
      buzzer.stopPlaying();
      
    } else if(start_flag) {
      motors.setSpeeds((int)leftMotorPWM, (int)rightMotorPWM);
    }
    
    motors.setSpeeds((int)leftMotorPWM, (int)rightMotorPWM);
  }

  
  }
  
  }
